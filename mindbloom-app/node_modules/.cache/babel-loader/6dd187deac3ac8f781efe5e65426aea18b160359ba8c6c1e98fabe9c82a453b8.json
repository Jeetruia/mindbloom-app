{"ast":null,"code":"// Speech types are defined globally\n\n// Simplified Text-to-Speech Service\nexport class TTSService {\n  constructor() {\n    this.synthesis = void 0;\n    this.voices = [];\n    this.currentVoice = null;\n    this.synthesis = window.speechSynthesis;\n    this.loadVoices();\n  }\n  loadVoices() {\n    this.voices = this.synthesis.getVoices();\n\n    // Prefer female voices for therapist persona\n    this.currentVoice = this.voices.find(voice => voice.name.includes('Female') || voice.name.includes('Karen') || voice.name.includes('Samantha') || voice.name.includes('Zira')) || this.voices[0];\n  }\n  async speak(text, options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!this.synthesis) {\n        reject(new Error('Speech synthesis not supported'));\n        return;\n      }\n\n      // Cancel any ongoing speech\n      this.synthesis.cancel();\n      const utterance = new SpeechSynthesisUtterance(text);\n      if (this.currentVoice) {\n        utterance.voice = this.currentVoice;\n      }\n      utterance.rate = options.rate || 0.9;\n      utterance.pitch = options.pitch || 1.0;\n      utterance.volume = options.volume || 1.0;\n      utterance.onend = () => resolve();\n      utterance.onerror = event => reject(event.error);\n      this.synthesis.speak(utterance);\n    });\n  }\n  stop() {\n    this.synthesis.cancel();\n  }\n  pause() {\n    this.synthesis.pause();\n  }\n  resume() {\n    this.synthesis.resume();\n  }\n  isSpeaking() {\n    return this.synthesis.speaking;\n  }\n  getAvailableVoices() {\n    return this.voices;\n  }\n  setVoice(voice) {\n    this.currentVoice = voice;\n  }\n}\n\n// Simplified Speech-to-Text Service\nexport class STTService {\n  constructor() {\n    this.recognition = null;\n    this.isListening = false;\n    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {\n      const SpeechRecognitionClass = window.SpeechRecognition || window.webkitSpeechRecognition;\n      this.recognition = new SpeechRecognitionClass();\n      if (this.recognition) {\n        this.recognition.continuous = false;\n        this.recognition.interimResults = true;\n        this.recognition.lang = 'en-US';\n      }\n    }\n  }\n  async startListening() {\n    return new Promise((resolve, reject) => {\n      if (!this.recognition) {\n        reject(new Error('Speech recognition not supported'));\n        return;\n      }\n      this.isListening = true;\n      this.recognition.onresult = event => {\n        const transcript = Array.from(event.results).map(result => result[0]).map(result => result.transcript).join('');\n        if (event.results[0].isFinal) {\n          this.isListening = false;\n          resolve(transcript);\n        }\n      };\n      this.recognition.onerror = event => {\n        this.isListening = false;\n        reject(new Error(event.error));\n      };\n      this.recognition.onend = () => {\n        this.isListening = false;\n      };\n      this.recognition.start();\n    });\n  }\n  stopListening() {\n    if (this.recognition && this.isListening) {\n      this.recognition.stop();\n      this.isListening = false;\n    }\n  }\n  isCurrentlyListening() {\n    return this.isListening;\n  }\n  setLanguage(lang) {\n    if (this.recognition) {\n      this.recognition.lang = lang;\n    }\n  }\n}\n\n// Simplified Lip Sync Service\nexport class LipSyncService {\n  constructor() {\n    this.audioContext = null;\n    try {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    } catch (error) {\n      console.warn('Audio context not supported:', error);\n    }\n  }\n\n  // Simplified viseme generation based on text analysis\n  generateVisemesFromText(text) {\n    const visemes = [];\n    const words = text.toLowerCase().split(/\\s+/);\n    let currentTime = 0;\n    for (const word of words) {\n      const phoneme = this.textToPhoneme(word);\n      const duration = Math.max(0.1, word.length * 0.05); // Minimum 100ms\n\n      visemes.push({\n        phoneme,\n        startTime: currentTime,\n        endTime: currentTime + duration\n      });\n      currentTime += duration + 0.1; // Small pause between words\n    }\n    return visemes;\n  }\n  textToPhoneme(word) {\n    // Simplified phoneme mapping based on common sounds\n    if (word.includes('a') || word.includes('e') || word.includes('i') || word.includes('o') || word.includes('u')) {\n      return 'A'; // Open mouth sounds\n    } else if (word.includes('m') || word.includes('b') || word.includes('p')) {\n      return 'M'; // Closed mouth sounds\n    } else if (word.includes('f') || word.includes('v')) {\n      return 'F'; // Lip-teeth sounds\n    } else if (word.includes('th')) {\n      return 'TH'; // Tongue sounds\n    } else {\n      return 'A'; // Default to open mouth\n    }\n  }\n  connectToAudioElement(audioElement) {\n    if (!this.audioContext) return;\n    try {\n      const source = this.audioContext.createMediaElementSource(audioElement);\n      source.connect(this.audioContext.destination);\n    } catch (error) {\n      console.warn('Could not connect audio element:', error);\n    }\n  }\n  getAudioLevel() {\n    // Simplified audio level detection\n    return Math.random() * 0.5 + 0.3; // Random level between 0.3 and 0.8\n  }\n}","map":{"version":3,"names":["TTSService","constructor","synthesis","voices","currentVoice","window","speechSynthesis","loadVoices","getVoices","find","voice","name","includes","speak","text","options","Promise","resolve","reject","Error","cancel","utterance","SpeechSynthesisUtterance","rate","pitch","volume","onend","onerror","event","error","stop","pause","resume","isSpeaking","speaking","getAvailableVoices","setVoice","STTService","recognition","isListening","SpeechRecognitionClass","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","lang","startListening","onresult","transcript","Array","from","results","map","result","join","isFinal","start","stopListening","isCurrentlyListening","setLanguage","LipSyncService","audioContext","AudioContext","webkitAudioContext","console","warn","generateVisemesFromText","visemes","words","toLowerCase","split","currentTime","word","phoneme","textToPhoneme","duration","Math","max","length","push","startTime","endTime","connectToAudioElement","audioElement","source","createMediaElementSource","connect","destination","getAudioLevel","random"],"sources":["/Users/jeetruia/MINDBLOOM/mindbloom-app/src/services/speechServiceSimple.ts"],"sourcesContent":["// Speech types are defined globally\n\n// Simplified Text-to-Speech Service\nexport class TTSService {\n  private synthesis: SpeechSynthesis;\n  private voices: SpeechSynthesisVoice[] = [];\n  private currentVoice: SpeechSynthesisVoice | null = null;\n\n  constructor() {\n    this.synthesis = window.speechSynthesis;\n    this.loadVoices();\n  }\n\n  private loadVoices() {\n    this.voices = this.synthesis.getVoices();\n    \n    // Prefer female voices for therapist persona\n    this.currentVoice = this.voices.find(voice => \n      voice.name.includes('Female') || \n      voice.name.includes('Karen') || \n      voice.name.includes('Samantha') ||\n      voice.name.includes('Zira')\n    ) || this.voices[0];\n  }\n\n  async speak(text: string, options: {\n    rate?: number;\n    pitch?: number;\n    volume?: number;\n  } = {}): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.synthesis) {\n        reject(new Error('Speech synthesis not supported'));\n        return;\n      }\n\n      // Cancel any ongoing speech\n      this.synthesis.cancel();\n\n      const utterance = new SpeechSynthesisUtterance(text);\n      \n      if (this.currentVoice) {\n        utterance.voice = this.currentVoice;\n      }\n\n      utterance.rate = options.rate || 0.9;\n      utterance.pitch = options.pitch || 1.0;\n      utterance.volume = options.volume || 1.0;\n\n      utterance.onend = () => resolve();\n      utterance.onerror = (event) => reject(event.error);\n\n      this.synthesis.speak(utterance);\n    });\n  }\n\n  stop() {\n    this.synthesis.cancel();\n  }\n\n  pause() {\n    this.synthesis.pause();\n  }\n\n  resume() {\n    this.synthesis.resume();\n  }\n\n  isSpeaking(): boolean {\n    return this.synthesis.speaking;\n  }\n\n  getAvailableVoices(): SpeechSynthesisVoice[] {\n    return this.voices;\n  }\n\n  setVoice(voice: SpeechSynthesisVoice) {\n    this.currentVoice = voice;\n  }\n}\n\n// Simplified Speech-to-Text Service\nexport class STTService {\n  private recognition: SpeechRecognition | null = null;\n  private isListening = false;\n\n  constructor() {\n    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {\n      const SpeechRecognitionClass = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;\n      this.recognition = new SpeechRecognitionClass();\n      \n      if (this.recognition) {\n        this.recognition.continuous = false;\n        this.recognition.interimResults = true;\n        this.recognition.lang = 'en-US';\n      }\n    }\n  }\n\n  async startListening(): Promise<string> {\n    return new Promise((resolve, reject) => {\n      if (!this.recognition) {\n        reject(new Error('Speech recognition not supported'));\n        return;\n      }\n\n      this.isListening = true;\n\n      this.recognition.onresult = (event: SpeechRecognitionEvent) => {\n        const transcript = Array.from(event.results)\n          .map(result => result[0])\n          .map(result => result.transcript)\n          .join('');\n\n        if (event.results[0].isFinal) {\n          this.isListening = false;\n          resolve(transcript);\n        }\n      };\n\n      this.recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n        this.isListening = false;\n        reject(new Error(event.error));\n      };\n\n      this.recognition.onend = () => {\n        this.isListening = false;\n      };\n\n      this.recognition.start();\n    });\n  }\n\n  stopListening() {\n    if (this.recognition && this.isListening) {\n      this.recognition.stop();\n      this.isListening = false;\n    }\n  }\n\n  isCurrentlyListening(): boolean {\n    return this.isListening;\n  }\n\n  setLanguage(lang: string) {\n    if (this.recognition) {\n      this.recognition.lang = lang;\n    }\n  }\n}\n\n// Simplified Lip Sync Service\nexport class LipSyncService {\n  private audioContext: AudioContext | null = null;\n\n  constructor() {\n    try {\n      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    } catch (error) {\n      console.warn('Audio context not supported:', error);\n    }\n  }\n\n  // Simplified viseme generation based on text analysis\n  generateVisemesFromText(text: string): Array<{phoneme: string, startTime: number, endTime: number}> {\n    const visemes = [];\n    const words = text.toLowerCase().split(/\\s+/);\n    \n    let currentTime = 0;\n    \n    for (const word of words) {\n      const phoneme = this.textToPhoneme(word);\n      const duration = Math.max(0.1, word.length * 0.05); // Minimum 100ms\n      \n      visemes.push({\n        phoneme,\n        startTime: currentTime,\n        endTime: currentTime + duration\n      });\n      \n      currentTime += duration + 0.1; // Small pause between words\n    }\n    \n    return visemes;\n  }\n\n  private textToPhoneme(word: string): string {\n    // Simplified phoneme mapping based on common sounds\n    if (word.includes('a') || word.includes('e') || word.includes('i') || word.includes('o') || word.includes('u')) {\n      return 'A'; // Open mouth sounds\n    } else if (word.includes('m') || word.includes('b') || word.includes('p')) {\n      return 'M'; // Closed mouth sounds\n    } else if (word.includes('f') || word.includes('v')) {\n      return 'F'; // Lip-teeth sounds\n    } else if (word.includes('th')) {\n      return 'TH'; // Tongue sounds\n    } else {\n      return 'A'; // Default to open mouth\n    }\n  }\n\n  connectToAudioElement(audioElement: HTMLAudioElement) {\n    if (!this.audioContext) return;\n\n    try {\n      const source = this.audioContext.createMediaElementSource(audioElement);\n      source.connect(this.audioContext.destination);\n    } catch (error) {\n      console.warn('Could not connect audio element:', error);\n    }\n  }\n\n  getAudioLevel(): number {\n    // Simplified audio level detection\n    return Math.random() * 0.5 + 0.3; // Random level between 0.3 and 0.8\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}