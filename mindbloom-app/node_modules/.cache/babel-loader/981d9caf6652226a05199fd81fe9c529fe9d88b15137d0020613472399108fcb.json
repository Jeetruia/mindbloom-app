{"ast":null,"code":"// Botpress Service Integration\n\nexport class BotpressService {\n  constructor(config) {\n    this.config = void 0;\n    this.conversationId = null;\n    this.isConnected = false;\n    this.config = config;\n    this.conversationId = config.conversationId || null;\n  }\n\n  // Initialize connection to Botpress\n  async initialize() {\n    try {\n      // Generate a unique conversation ID if not provided\n      if (!this.conversationId) {\n        this.conversationId = `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      }\n\n      // Test connection by sending a ping\n      await this.sendMessage('ping');\n      this.isConnected = true;\n      console.log('Botpress service initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize Botpress service:', error);\n      throw error;\n    }\n  }\n\n  // Send message to Botpress and get response\n  async sendMessage(message) {\n    try {\n      const response = await fetch('https://cdn.botpress.cloud/webchat/v3.2/shareable.html', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          type: 'text',\n          text: message,\n          userId: this.config.userId,\n          conversationId: this.conversationId,\n          botId: this.config.botId\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`Botpress API error: ${response.status}`);\n      }\n      const data = await response.json();\n      return this.parseBotpressResponse(data);\n    } catch (error) {\n      console.error('Error sending message to Botpress:', error);\n      // Fallback to local AI response\n      return this.getFallbackResponse(message);\n    }\n  }\n\n  // Parse Botpress response format\n  parseBotpressResponse(data) {\n    const messages = [];\n    if (data.messages && Array.isArray(data.messages)) {\n      data.messages.forEach((msg, index) => {\n        messages.push({\n          id: msg.id || `msg_${Date.now()}_${index}`,\n          type: msg.type || 'text',\n          text: msg.text || msg.message || '',\n          data: msg.data,\n          timestamp: new Date()\n        });\n      });\n    } else if (data.text) {\n      messages.push({\n        id: `msg_${Date.now()}`,\n        type: 'text',\n        text: data.text,\n        timestamp: new Date()\n      });\n    }\n    return messages;\n  }\n\n  // Fallback response when Botpress is unavailable\n  getFallbackResponse(message) {\n    const responses = [\"I'm here to listen and support you. How are you feeling today?\", \"Thank you for sharing that with me. I understand this might be difficult to talk about.\", \"I'm glad you reached out. Let's work through this together, one step at a time.\", \"Your feelings are valid, and it's okay to not be okay sometimes. I'm here to help.\", \"I can hear that you're going through a challenging time. You're not alone in this.\"];\n    const randomResponse = responses[Math.floor(Math.random() * responses.length)];\n    return [{\n      id: `fallback_${Date.now()}`,\n      type: 'text',\n      text: randomResponse,\n      timestamp: new Date()\n    }];\n  }\n\n  // Get initial greeting message\n  async getInitialGreeting() {\n    try {\n      // Try to get a personalized greeting from Botpress\n      const response = await this.sendMessage('start conversation');\n\n      // If no response or empty, use default greeting\n      if (response.length === 0 || !response[0].text) {\n        return [{\n          id: `greeting_${Date.now()}`,\n          type: 'text',\n          text: \"Hello! I'm Mira, your wellness guide. I'm here to listen and support you. How are you feeling today?\",\n          timestamp: new Date()\n        }];\n      }\n      return response;\n    } catch (error) {\n      console.warn('Failed to get Botpress greeting, using fallback:', error);\n      return [{\n        id: `greeting_${Date.now()}`,\n        type: 'text',\n        text: \"Hello! I'm Mira, your wellness guide. I'm here to listen and support you. How are you feeling today?\",\n        timestamp: new Date()\n      }];\n    }\n  }\n\n  // Check if service is connected\n  isServiceConnected() {\n    return this.isConnected;\n  }\n\n  // Get conversation ID\n  getConversationId() {\n    return this.conversationId;\n  }\n}\n\n// Create a singleton instance\nexport const botpressService = new BotpressService({\n  botId: 'mindbloom-therapist',\n  userId: 'user_' + Date.now(),\n  apiUrl: 'https://cdn.botpress.cloud/webchat/v3.2/shareable.html'\n});","map":{"version":3,"names":["BotpressService","constructor","config","conversationId","isConnected","initialize","Date","now","Math","random","toString","substr","sendMessage","console","log","error","message","response","fetch","method","headers","body","JSON","stringify","type","text","userId","botId","ok","Error","status","data","json","parseBotpressResponse","getFallbackResponse","messages","Array","isArray","forEach","msg","index","push","id","timestamp","responses","randomResponse","floor","length","getInitialGreeting","warn","isServiceConnected","getConversationId","botpressService","apiUrl"],"sources":["/Users/jeetruia/MINDBLOOM/mindbloom-app/src/services/botpressService.ts"],"sourcesContent":["// Botpress Service Integration\nexport interface BotpressMessage {\n  id: string;\n  type: 'text' | 'image' | 'file' | 'card' | 'carousel' | 'quick_reply';\n  text?: string;\n  data?: any;\n  timestamp: Date;\n}\n\nexport interface BotpressConfig {\n  botId: string;\n  userId: string;\n  conversationId?: string;\n  apiUrl?: string;\n}\n\nexport class BotpressService {\n  private config: BotpressConfig;\n  private conversationId: string | null = null;\n  private isConnected = false;\n\n  constructor(config: BotpressConfig) {\n    this.config = config;\n    this.conversationId = config.conversationId || null;\n  }\n\n  // Initialize connection to Botpress\n  async initialize(): Promise<void> {\n    try {\n      // Generate a unique conversation ID if not provided\n      if (!this.conversationId) {\n        this.conversationId = `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      }\n\n      // Test connection by sending a ping\n      await this.sendMessage('ping');\n      this.isConnected = true;\n      console.log('Botpress service initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize Botpress service:', error);\n      throw error;\n    }\n  }\n\n  // Send message to Botpress and get response\n  async sendMessage(message: string): Promise<BotpressMessage[]> {\n    try {\n      const response = await fetch('https://cdn.botpress.cloud/webchat/v3.2/shareable.html', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          type: 'text',\n          text: message,\n          userId: this.config.userId,\n          conversationId: this.conversationId,\n          botId: this.config.botId\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`Botpress API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n      return this.parseBotpressResponse(data);\n    } catch (error) {\n      console.error('Error sending message to Botpress:', error);\n      // Fallback to local AI response\n      return this.getFallbackResponse(message);\n    }\n  }\n\n  // Parse Botpress response format\n  private parseBotpressResponse(data: any): BotpressMessage[] {\n    const messages: BotpressMessage[] = [];\n    \n    if (data.messages && Array.isArray(data.messages)) {\n      data.messages.forEach((msg: any, index: number) => {\n        messages.push({\n          id: msg.id || `msg_${Date.now()}_${index}`,\n          type: msg.type || 'text',\n          text: msg.text || msg.message || '',\n          data: msg.data,\n          timestamp: new Date()\n        });\n      });\n    } else if (data.text) {\n      messages.push({\n        id: `msg_${Date.now()}`,\n        type: 'text',\n        text: data.text,\n        timestamp: new Date()\n      });\n    }\n\n    return messages;\n  }\n\n  // Fallback response when Botpress is unavailable\n  private getFallbackResponse(message: string): BotpressMessage[] {\n    const responses = [\n      \"I'm here to listen and support you. How are you feeling today?\",\n      \"Thank you for sharing that with me. I understand this might be difficult to talk about.\",\n      \"I'm glad you reached out. Let's work through this together, one step at a time.\",\n      \"Your feelings are valid, and it's okay to not be okay sometimes. I'm here to help.\",\n      \"I can hear that you're going through a challenging time. You're not alone in this.\"\n    ];\n\n    const randomResponse = responses[Math.floor(Math.random() * responses.length)];\n    \n    return [{\n      id: `fallback_${Date.now()}`,\n      type: 'text',\n      text: randomResponse,\n      timestamp: new Date()\n    }];\n  }\n\n  // Get initial greeting message\n  async getInitialGreeting(): Promise<BotpressMessage[]> {\n    try {\n      // Try to get a personalized greeting from Botpress\n      const response = await this.sendMessage('start conversation');\n      \n      // If no response or empty, use default greeting\n      if (response.length === 0 || !response[0].text) {\n        return [{\n          id: `greeting_${Date.now()}`,\n          type: 'text',\n          text: \"Hello! I'm Mira, your wellness guide. I'm here to listen and support you. How are you feeling today?\",\n          timestamp: new Date()\n        }];\n      }\n      \n      return response;\n    } catch (error) {\n      console.warn('Failed to get Botpress greeting, using fallback:', error);\n      return [{\n        id: `greeting_${Date.now()}`,\n        type: 'text',\n        text: \"Hello! I'm Mira, your wellness guide. I'm here to listen and support you. How are you feeling today?\",\n        timestamp: new Date()\n      }];\n    }\n  }\n\n  // Check if service is connected\n  isServiceConnected(): boolean {\n    return this.isConnected;\n  }\n\n  // Get conversation ID\n  getConversationId(): string | null {\n    return this.conversationId;\n  }\n}\n\n// Create a singleton instance\nexport const botpressService = new BotpressService({\n  botId: 'mindbloom-therapist',\n  userId: 'user_' + Date.now(),\n  apiUrl: 'https://cdn.botpress.cloud/webchat/v3.2/shareable.html'\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}