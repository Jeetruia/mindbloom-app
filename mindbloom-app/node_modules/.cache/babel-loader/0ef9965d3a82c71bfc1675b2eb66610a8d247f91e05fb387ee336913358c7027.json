{"ast":null,"code":"import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { TTSService } from '../services/speechServiceSimple';\nimport { botpressService } from '../services/botpressService';\nconst CRISIS_KEYWORDS = {\n  critical: ['suicide', 'kill myself', 'end it all', 'not worth living', 'want to die'],\n  high: ['depressed', 'hopeless', 'worthless', 'can\\'t go on', 'give up'],\n  medium: ['sad', 'lonely', 'anxious', 'worried', 'stressed'],\n  low: ['tired', 'overwhelmed', 'difficult', 'challenging']\n};\nexport const useStore = create()(persist((set, get) => ({\n  // Initial state\n  user: null,\n  isLoading: true,\n  messages: [],\n  isTyping: false,\n  avatarState: {\n    isVisible: false,\n    isSpeaking: false,\n    currentAnimation: 'idle',\n    emotion: {\n      type: 'neutral',\n      intensity: 0.5\n    },\n    position: {\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  },\n  crisisDetected: null,\n  sessions: [],\n  ttsService: new TTSService(),\n  isListening: false,\n  botpressConnected: false,\n  hasShownInitialGreeting: false,\n  // Actions\n  setUser: user => set({\n    user\n  }),\n  addMessage: message => set(state => ({\n    messages: [...state.messages, message]\n  })),\n  setTyping: isTyping => set({\n    isTyping\n  }),\n  updateAvatarState: newState => set(state => ({\n    avatarState: {\n      ...state.avatarState,\n      ...newState\n    }\n  })),\n  setCrisisDetected: crisis => set({\n    crisisDetected: crisis\n  }),\n  addSession: session => set(state => ({\n    sessions: [...state.sessions, session]\n  })),\n  initializeApp: async () => {\n    set({\n      isLoading: true\n    });\n    try {\n      // Check for existing user in localStorage\n      const savedUser = localStorage.getItem('mindbloom-user');\n      if (savedUser) {\n        const user = JSON.parse(savedUser);\n        set({\n          user,\n          isLoading: false\n        });\n      } else {\n        set({\n          isLoading: false\n        });\n      }\n    } catch (error) {\n      console.error('Error initializing app:', error);\n      set({\n        isLoading: false\n      });\n    }\n  },\n  sendMessage: async content => {\n    const {\n      user,\n      addMessage,\n      setTyping,\n      processCrisisDetection,\n      setCrisisDetected\n    } = get();\n    if (!user) return;\n\n    // Add user message\n    const userMessage = {\n      id: Date.now().toString(),\n      userId: user.id,\n      content,\n      isFromUser: true,\n      timestamp: new Date()\n    };\n    addMessage(userMessage);\n\n    // Check for crisis keywords\n    const crisis = processCrisisDetection(content);\n    if (crisis) {\n      setCrisisDetected(crisis);\n    }\n    setTyping(true);\n    try {\n      // Use ONLY Botpress for AI response\n      const botpressMessages = await botpressService.sendMessage(content);\n      let aiResponse = '';\n      if (botpressMessages.length > 0) {\n        aiResponse = botpressMessages[0].text || '';\n      }\n\n      // If no response from Botpress, use a simple fallback\n      if (!aiResponse) {\n        aiResponse = \"I'm here to listen and support you. How are you feeling today?\";\n      }\n      const aiMessage = {\n        id: (Date.now() + 1).toString(),\n        userId: 'ai',\n        content: aiResponse,\n        isFromUser: false,\n        timestamp: new Date(),\n        emotion: {\n          type: 'encouraging',\n          intensity: 0.8\n        }\n      };\n      addMessage(aiMessage);\n\n      // Update avatar to speak and use TTS\n      get().updateAvatarState({\n        isSpeaking: true,\n        currentAnimation: 'speaking',\n        emotion: {\n          type: 'encouraging',\n          intensity: 0.8\n        }\n      });\n\n      // Use TTS to speak the response\n      try {\n        await get().speakText(aiResponse);\n      } catch (error) {\n        console.warn('TTS failed:', error);\n      }\n\n      // Stop speaking after TTS completes\n      get().updateAvatarState({\n        isSpeaking: false,\n        currentAnimation: 'idle'\n      });\n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setTyping(false);\n    }\n  },\n  processCrisisDetection: message => {\n    const lowerMessage = message.toLowerCase();\n    for (const [severity, keywords] of Object.entries(CRISIS_KEYWORDS)) {\n      for (const keyword of keywords) {\n        if (lowerMessage.includes(keyword)) {\n          return {\n            keywords: [keyword],\n            severity: severity,\n            action: severity === 'critical' ? 'emergency' : severity === 'high' ? 'escalate' : 'monitor'\n          };\n        }\n      }\n    }\n    return null;\n  },\n  speakText: async text => {\n    const {\n      ttsService\n    } = get();\n    try {\n      await ttsService.speak(text, {\n        rate: 0.9,\n        pitch: 1.0,\n        volume: 0.8\n      });\n    } catch (error) {\n      console.error('TTS Error:', error);\n      throw error;\n    }\n  },\n  initializeBotpress: async () => {\n    try {\n      await botpressService.initialize();\n      set({\n        botpressConnected: true\n      });\n      console.log('Botpress initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize Botpress:', error);\n      set({\n        botpressConnected: false\n      });\n    }\n  },\n  showInitialGreeting: async () => {\n    const {\n      hasShownInitialGreeting,\n      addMessage,\n      updateAvatarState,\n      speakText\n    } = get();\n    if (hasShownInitialGreeting) return;\n    try {\n      // Use ONLY Botpress for greeting\n      const botpressMessages = await botpressService.getInitialGreeting();\n      let greetingText = '';\n      if (botpressMessages.length > 0) {\n        greetingText = botpressMessages[0].text || '';\n      }\n\n      // Fallback greeting if Botpress fails\n      if (!greetingText) {\n        greetingText = \"Hello! I'm Mira, your wellness guide. I'm here to listen and support you. How are you feeling today?\";\n      }\n      const greetingMessage = {\n        id: `greeting_${Date.now()}`,\n        userId: 'ai',\n        content: greetingText,\n        isFromUser: false,\n        timestamp: new Date(),\n        emotion: {\n          type: 'welcoming',\n          intensity: 0.9\n        }\n      };\n      addMessage(greetingMessage);\n\n      // Update avatar to speak\n      updateAvatarState({\n        isSpeaking: true,\n        currentAnimation: 'speaking',\n        emotion: {\n          type: 'welcoming',\n          intensity: 0.9\n        }\n      });\n\n      // Speak the greeting\n      try {\n        await speakText(greetingText);\n      } catch (error) {\n        console.warn('TTS failed for greeting:', error);\n      }\n\n      // Stop speaking\n      updateAvatarState({\n        isSpeaking: false,\n        currentAnimation: 'idle'\n      });\n      set({\n        hasShownInitialGreeting: true\n      });\n    } catch (error) {\n      console.error('Error showing initial greeting:', error);\n    }\n  },\n  setBotpressConnected: connected => set({\n    botpressConnected: connected\n  })\n}), {\n  name: 'mindbloom-storage',\n  partialize: state => ({\n    user: state.user,\n    sessions: state.sessions\n  })\n}));\n\n// Local AI response generation removed - using only Botpress","map":{"version":3,"names":["create","persist","TTSService","botpressService","CRISIS_KEYWORDS","critical","high","medium","low","useStore","set","get","user","isLoading","messages","isTyping","avatarState","isVisible","isSpeaking","currentAnimation","emotion","type","intensity","position","x","y","z","crisisDetected","sessions","ttsService","isListening","botpressConnected","hasShownInitialGreeting","setUser","addMessage","message","state","setTyping","updateAvatarState","newState","setCrisisDetected","crisis","addSession","session","initializeApp","savedUser","localStorage","getItem","JSON","parse","error","console","sendMessage","content","processCrisisDetection","userMessage","id","Date","now","toString","userId","isFromUser","timestamp","botpressMessages","aiResponse","length","text","aiMessage","speakText","warn","lowerMessage","toLowerCase","severity","keywords","Object","entries","keyword","includes","action","speak","rate","pitch","volume","initializeBotpress","initialize","log","showInitialGreeting","getInitialGreeting","greetingText","greetingMessage","setBotpressConnected","connected","name","partialize"],"sources":["/Users/jeetruia/MINDBLOOM/mindbloom-app/src/hooks/useStore.ts"],"sourcesContent":["import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { User, ChatMessage, AvatarState, CrisisDetection, WellnessSession } from '../types';\nimport { TTSService } from '../services/speechServiceSimple';\nimport { botpressService } from '../services/botpressService';\n\ninterface AppState {\n  // User state\n  user: User | null;\n  isLoading: boolean;\n  \n  // Chat state\n  messages: ChatMessage[];\n  isTyping: boolean;\n  \n  // Avatar state\n  avatarState: AvatarState;\n  \n  // Crisis detection\n  crisisDetected: CrisisDetection | null;\n  \n  // Sessions\n  sessions: WellnessSession[];\n  \n  // Speech service\n  ttsService: TTSService;\n  isListening: boolean;\n  \n  // Botpress state\n  botpressConnected: boolean;\n  hasShownInitialGreeting: boolean;\n  \n  // Actions\n  setUser: (user: User) => void;\n  addMessage: (message: ChatMessage) => void;\n  setTyping: (isTyping: boolean) => void;\n  updateAvatarState: (state: Partial<AvatarState>) => void;\n  setCrisisDetected: (crisis: CrisisDetection | null) => void;\n  addSession: (session: WellnessSession) => void;\n  initializeApp: () => Promise<void>;\n  sendMessage: (content: string) => Promise<void>;\n  processCrisisDetection: (message: string) => CrisisDetection | null;\n  speakText: (text: string) => Promise<void>;\n  startListening: () => void;\n  stopListening: () => void;\n  initializeBotpress: () => Promise<void>;\n  showInitialGreeting: () => Promise<void>;\n  setBotpressConnected: (connected: boolean) => void;\n}\n\nconst CRISIS_KEYWORDS = {\n  critical: ['suicide', 'kill myself', 'end it all', 'not worth living', 'want to die'],\n  high: ['depressed', 'hopeless', 'worthless', 'can\\'t go on', 'give up'],\n  medium: ['sad', 'lonely', 'anxious', 'worried', 'stressed'],\n  low: ['tired', 'overwhelmed', 'difficult', 'challenging']\n};\n\nexport const useStore = create<AppState>()(\n  persist(\n    (set, get) => ({\n      // Initial state\n      user: null,\n      isLoading: true,\n      messages: [],\n      isTyping: false,\n      avatarState: {\n        isVisible: false,\n        isSpeaking: false,\n        currentAnimation: 'idle',\n        emotion: { type: 'neutral', intensity: 0.5 },\n        position: { x: 0, y: 0, z: 0 }\n      },\n      crisisDetected: null,\n      sessions: [],\n      ttsService: new TTSService(),\n      isListening: false,\n      botpressConnected: false,\n      hasShownInitialGreeting: false,\n\n      // Actions\n      setUser: (user) => set({ user }),\n      \n      addMessage: (message) => set((state) => ({\n        messages: [...state.messages, message]\n      })),\n      \n      setTyping: (isTyping) => set({ isTyping }),\n      \n      updateAvatarState: (newState) => set((state) => ({\n        avatarState: { ...state.avatarState, ...newState }\n      })),\n      \n      setCrisisDetected: (crisis) => set({ crisisDetected: crisis }),\n      \n      addSession: (session) => set((state) => ({\n        sessions: [...state.sessions, session]\n      })),\n\n      initializeApp: async () => {\n        set({ isLoading: true });\n        \n        try {\n          // Check for existing user in localStorage\n          const savedUser = localStorage.getItem('mindbloom-user');\n          if (savedUser) {\n            const user = JSON.parse(savedUser);\n            set({ user, isLoading: false });\n          } else {\n            set({ isLoading: false });\n          }\n        } catch (error) {\n          console.error('Error initializing app:', error);\n          set({ isLoading: false });\n        }\n      },\n\n      sendMessage: async (content) => {\n        const { user, addMessage, setTyping, processCrisisDetection, setCrisisDetected } = get();\n        \n        if (!user) return;\n\n        // Add user message\n        const userMessage: ChatMessage = {\n          id: Date.now().toString(),\n          userId: user.id,\n          content,\n          isFromUser: true,\n          timestamp: new Date()\n        };\n        addMessage(userMessage);\n\n        // Check for crisis keywords\n        const crisis = processCrisisDetection(content);\n        if (crisis) {\n          setCrisisDetected(crisis);\n        }\n\n        setTyping(true);\n\n        try {\n          // Use ONLY Botpress for AI response\n          const botpressMessages = await botpressService.sendMessage(content);\n          let aiResponse = '';\n          \n          if (botpressMessages.length > 0) {\n            aiResponse = botpressMessages[0].text || '';\n          }\n          \n          // If no response from Botpress, use a simple fallback\n          if (!aiResponse) {\n            aiResponse = \"I'm here to listen and support you. How are you feeling today?\";\n          }\n          \n          const aiMessage: ChatMessage = {\n            id: (Date.now() + 1).toString(),\n            userId: 'ai',\n            content: aiResponse,\n            isFromUser: false,\n            timestamp: new Date(),\n            emotion: { type: 'encouraging', intensity: 0.8 }\n          };\n          \n          addMessage(aiMessage);\n          \n          // Update avatar to speak and use TTS\n          get().updateAvatarState({\n            isSpeaking: true,\n            currentAnimation: 'speaking',\n            emotion: { type: 'encouraging', intensity: 0.8 }\n          });\n\n          // Use TTS to speak the response\n          try {\n            await get().speakText(aiResponse);\n          } catch (error) {\n            console.warn('TTS failed:', error);\n          }\n\n          // Stop speaking after TTS completes\n          get().updateAvatarState({\n            isSpeaking: false,\n            currentAnimation: 'idle'\n          });\n\n        } catch (error) {\n          console.error('Error sending message:', error);\n        } finally {\n          setTyping(false);\n        }\n      },\n\n      processCrisisDetection: (message) => {\n        const lowerMessage = message.toLowerCase();\n        \n        for (const [severity, keywords] of Object.entries(CRISIS_KEYWORDS)) {\n          for (const keyword of keywords) {\n            if (lowerMessage.includes(keyword)) {\n              return {\n                keywords: [keyword],\n                severity: severity as CrisisDetection['severity'],\n                action: severity === 'critical' ? 'emergency' : \n                       severity === 'high' ? 'escalate' : 'monitor'\n              };\n            }\n          }\n        }\n        \n        return null;\n      },\n\n      speakText: async (text) => {\n        const { ttsService } = get();\n        try {\n          await ttsService.speak(text, {\n            rate: 0.9,\n            pitch: 1.0,\n            volume: 0.8\n          });\n        } catch (error) {\n          console.error('TTS Error:', error);\n          throw error;\n        }\n      },\n\n      initializeBotpress: async () => {\n        try {\n          await botpressService.initialize();\n          set({ botpressConnected: true });\n          console.log('Botpress initialized successfully');\n        } catch (error) {\n          console.error('Failed to initialize Botpress:', error);\n          set({ botpressConnected: false });\n        }\n      },\n\n      showInitialGreeting: async () => {\n        const { hasShownInitialGreeting, addMessage, updateAvatarState, speakText } = get();\n        \n        if (hasShownInitialGreeting) return;\n\n        try {\n          // Use ONLY Botpress for greeting\n          const botpressMessages = await botpressService.getInitialGreeting();\n          let greetingText = '';\n          \n          if (botpressMessages.length > 0) {\n            greetingText = botpressMessages[0].text || '';\n          }\n          \n          // Fallback greeting if Botpress fails\n          if (!greetingText) {\n            greetingText = \"Hello! I'm Mira, your wellness guide. I'm here to listen and support you. How are you feeling today?\";\n          }\n\n          const greetingMessage: ChatMessage = {\n            id: `greeting_${Date.now()}`,\n            userId: 'ai',\n            content: greetingText,\n            isFromUser: false,\n            timestamp: new Date(),\n            emotion: { type: 'welcoming', intensity: 0.9 }\n          };\n\n          addMessage(greetingMessage);\n\n          // Update avatar to speak\n          updateAvatarState({\n            isSpeaking: true,\n            currentAnimation: 'speaking',\n            emotion: { type: 'welcoming', intensity: 0.9 }\n          });\n\n          // Speak the greeting\n          try {\n            await speakText(greetingText);\n          } catch (error) {\n            console.warn('TTS failed for greeting:', error);\n          }\n\n          // Stop speaking\n          updateAvatarState({\n            isSpeaking: false,\n            currentAnimation: 'idle'\n          });\n\n          set({ hasShownInitialGreeting: true });\n        } catch (error) {\n          console.error('Error showing initial greeting:', error);\n        }\n      },\n\n      setBotpressConnected: (connected) => set({ botpressConnected: connected })\n    }),\n    {\n      name: 'mindbloom-storage',\n      partialize: (state) => ({\n        user: state.user,\n        sessions: state.sessions\n      })\n    }\n  )\n);\n\n// Local AI response generation removed - using only Botpress\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}